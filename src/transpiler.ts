import { OrganismDefinition, DNAConfig, AgentInterface, OrganismInterface } from './types';

export class Transpiler {
  transpile(organism: OrganismDefinition): string {
    const className = organism.name;
    
    let output = '';
    
    // Add imports
    output += this.generateImports();
    output += '\n\n';
    
    // Generate agent classes if needed
    if (organism.agents && organism.agents.length > 0) {
      output += this.generateAgentClasses(organism.agents);
      output += '\n\n';
    }
    
    // Generate main organism class
    output += this.generateOrganismClass(organism);
    
    return output;
  }

  private generateImports(): string {
    return `// Generated by DNA-Lang Transpiler
import { OrganismInterface, AgentInterface, DNAConfig } from './dna-lang-runtime';`;
  }

  private generateAgentClasses(agents: any[]): string {
    const agentTypes = new Set(agents.map(a => a.type));
    let output = '';
    
    agentTypes.forEach(type => {
      output += `
class ${type} implements AgentInterface {
  name: string;
  type: string;
  private config: Record<string, any>;

  constructor(name: string, config: Record<string, any> = {}) {
    this.name = name;
    this.type = '${type}';
    this.config = config;
  }

  async execute(task: string): Promise<any> {
    console.log(\`ü§ñ \${this.name} (\${this.type}) executing task: \${task}\`);
    
    // Basic agent logic based on type
    switch (this.type) {
      case 'ArchitectAgent':
        return this.executeArchitectTask(task);
      case 'SecurityAgent':
        return this.executeSecurityTask(task);
      case 'DeveloperAgent':
        return this.executeDeveloperTask(task);
      default:
        return { result: 'Task completed', task };
    }
  }

  private async executeArchitectTask(task: string): Promise<any> {
    const focus = this.config.focus || 'microservices';
    return { 
      design: \`Architectural design for \${task} using \${focus} approach\`,
      recommendations: ['scalability', 'maintainability', 'performance']
    };
  }

  private async executeSecurityTask(task: string): Promise<any> {
    const vigilance = this.config.vigilance || 'normal';
    return {
      securityAnalysis: \`Security analysis for \${task} with \${vigilance} vigilance\`,
      threats: ['injection', 'authentication', 'authorization'],
      mitigations: ['input validation', 'secure authentication', 'role-based access']
    };
  }

  private async executeDeveloperTask(task: string): Promise<any> {
    const speed = this.config.speed || 'normal';
    return {
      implementation: \`Implementation of \${task} at \${speed} speed\`,
      codeQuality: speed === 'fast' ? 'standard' : 'high',
      testCoverage: speed === 'fast' ? 70 : 90
    };
  }
}
`;
    });
    
    return output;
  }

  private generateOrganismClass(organism: OrganismDefinition): string {
    const className = organism.name;
    
    let output = `export class ${className} implements OrganismInterface {
  public readonly dna: DNAConfig = ${JSON.stringify(organism.dna, null, 4)};
  
  public readonly agents = new Map<string, AgentInterface>();
  private isEvolutionActive = false;
  private evolutionInterval?: NodeJS.Timeout;

  constructor() {
    this.initializeAgents();
    this.startEvolutionLoop();
  }

  private initializeAgents(): void {`;

    if (organism.agents && organism.agents.length > 0) {
      organism.agents.forEach(agent => {
        const configStr = JSON.stringify(agent.config);
        output += `
    this.agents.set('${agent.name}', new ${agent.type}('${agent.name}', ${configStr}));`;
      });
    }

    output += `
    console.log(\`üß¨ \${this.constructor.name} initialized with \${this.agents.size} agents\`);
  }

  private startEvolutionLoop(): void {
    if (this.dna.evolution_rate === 'adaptive') {
      this.evolutionInterval = setInterval(() => {
        this.evolve().catch(console.error);
      }, 5000); // Evolve every 5 seconds
    }
  }

  public async evolve(): Promise<void> {
    if (this.isEvolutionActive) return;
    
    this.isEvolutionActive = true;
    console.log(\`üß¨ \${this.constructor.name} is evolving...\`);
    
    try {`;

    // Add trait-based evolution
    if (organism.genome && organism.genome.length > 0) {
      organism.genome.forEach(trait => {
        const methodName = trait.name.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
        output += `
      await this.${methodName}();`;
      });
    }

    output += `
      
      console.log(\`‚ú® \${this.constructor.name} evolution cycle completed\`);
    } finally {
      this.isEvolutionActive = false;
    }
  }

  public async selfHeal(): Promise<void> {
    if (this.dna.immune_system) {
      console.log(\`üõ°Ô∏è \${this.constructor.name} immune system activating...\`);
      
      // Basic self-healing logic
      const healthCheck = await this.performHealthCheck();
      if (!healthCheck.isHealthy) {
        console.log(\`üîß Applying self-healing measures: \${healthCheck.issues.join(', ')}\`);
        await this.applyHealingMeasures(healthCheck.issues);
      }
    }
  }

  private async performHealthCheck(): Promise<{ isHealthy: boolean; issues: string[] }> {
    const issues: string[] = [];
    
    // Check agent health
    for (const [name, agent] of this.agents) {
      try {
        await agent.execute('health_check');
      } catch (error) {
        issues.push(\`Agent \${name} unhealthy\`);
      }
    }
    
    return {
      isHealthy: issues.length === 0,
      issues
    };
  }

  private async applyHealingMeasures(issues: string[]): Promise<void> {
    for (const issue of issues) {
      console.log(\`ü©π Healing: \${issue}\`);
      // Basic healing logic would go here
    }
  }`;

    // Add trait methods
    if (organism.genome && organism.genome.length > 0) {
      organism.genome.forEach(trait => {
        const methodName = trait.name.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
        output += `

  private async ${methodName}(): Promise<void> {
    console.log(\`‚ö° Activating trait: ${trait.name} (${trait.value})\`);
    
    // Trait-specific logic would be implemented here
    // For now, we'll simulate the trait activation
    await new Promise(resolve => setTimeout(resolve, 100));
  }`;
      });
    }

    // Add gene methods
    if (organism.genes && organism.genes.length > 0) {
      organism.genes.forEach(gene => {
        const methodName = gene.name.toLowerCase().replace(/([a-z])([A-Z])/g, '$1$2').replace(/\s+/g, '');
        output += `

  public async ${methodName}(): Promise<any> {
    console.log(\`üß¨ Executing gene: ${gene.name}\`);
    
    try {
      // Gene implementation
      ${gene.implementation?.code || '// Implementation would go here'}
      
      return { success: true, gene: '${gene.name}' };
    } catch (error) {
      console.error(\`‚ùå Gene ${gene.name} failed:\`, error);
      
      // Apply immune responses if available
      ${gene.immune_responses ? this.generateImmuneResponses(gene.immune_responses) : ''}
      
      throw error;
    }
  }`;
      });
    }

    // Add collaboration methods
    if (organism.collaborations && organism.collaborations.length > 0) {
      organism.collaborations.forEach(collab => {
        const methodName = collab.name.toLowerCase().replace(/([a-z])([A-Z])/g, '$1$2').replace(/\s+/g, '');
        output += `

  public async ${methodName}(): Promise<any> {
    console.log(\`ü§ù Starting collaboration: ${collab.name}\`);
    
    const participants = [${collab.participants.map(p => `'${p}'`).join(', ')}];
    const workflow = [${collab.workflow.map(w => `'${w}'`).join(', ')}];
    
    const results: any[] = [];
    
    for (const step of workflow) {
      const [agentName, task] = step.split('.');
      const agent = this.agents.get(agentName);
      
      if (agent) {
        const result = await agent.execute(task || step);
        results.push({ agent: agentName, task, result });
      } else {
        console.warn(\`‚ö†Ô∏è Agent \${agentName} not found for step: \${step}\`);
      }
    }
    
    return { collaboration: '${collab.name}', results };
  }`;
      });
    }

    output += `

  public destroy(): void {
    if (this.evolutionInterval) {
      clearInterval(this.evolutionInterval);
    }
    console.log(\`üîö \${this.constructor.name} organism destroyed\`);
  }
}`;

    return output;
  }

  private generateImmuneResponses(responses: Record<string, string>): string {
    let output = '';
    
    Object.entries(responses).forEach(([threat, response]) => {
      output += `
      if (error.message.includes('${threat}')) {
        console.log(\`üõ°Ô∏è Immune response activated for ${threat}: ${response}\`);
        // Implement specific response logic here
      }`;
    });
    
    return output;
  }
}